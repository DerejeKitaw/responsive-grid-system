<article>
Отзывчивая сетка — один из лучших инструментов для создания уникального дизайна.
Вы можете настроить всё, что нужно — количество и ширину колонок, отступы и даже
контрольные точки, при достижении которых перестраивается раскладка страницы.

К сожалению, большинство людей даже не пытаются создавать свои сетки из-за того,
что им не хватает знаний и уверенности в своих силах.

В этой статье я хочу помочь вам обрести веру в себя и знания, нужные для
создания собственной сетки. Надеюсь, после прочтения статьи вы отложите
фреймворки и попробуете создать собственную сетку для следующего проекта.

## Что входит в сетку?

Прежде чем браться за создание сетки, вам нужно сделать три вещи.

**Во-первых, спроектировать сетку.**

Сколько будет колонок? Они будут одинаковой или разной ширины? Какие у них будут
ширина и отступы?

Вы сможете правильно просчитать параметры сетки только после того, как ответите
на эти вопросы. Чтобы помочь вам, я написал статью о [проектировании сеток][1].
Прочтите её, что бы научиться грамотно проектировать сетки.

**Во-вторых, понять, как сетка должна вести себя на разных вьюпортах.**

Будете ли вы менять размеры колонок и отступов пропорционально ширине вьюпорта?
Или вы будете менять только ширину колонок, оставляя отступы фиксированными?
Может, вы будете менять количество колонок в определённых контрольных точках?

На эти вопросы тоже нужно ответить. Это поможет рассчитать ширину колонок
и отступов. Я писал об этом в той же [статье о проектировании сеток][2], так что
обратитесь к ней в случае сомнений.

**В-третьих, понять, нравится ли вам писать классы сетки в разметке?**

Когда речь заходит о сетках, мир фронтенда делится на две фракции.

Одни пишут классы сетки в разметке (такой подход используется, например,
в Bootstrap и Foundation). Я называю это **HTML-сетками**. Разметка выглядит так:

    <div class="container">
      <div class="row">
        <div class="col-md-9">Content</div>
        <div class="col-md-3">Sidebar</div>
      </div>
    </div>

Другие создают сетки на CSS. Я называю это **CSS-сетками**.

С CSS-сетками разметка получается проще, чем с HTML-сетками.
Вам не приходится повторять одни и те же классы, размечая визуально похожие
части документа. Также вам не нужно помнить, как называются классы сетки:

    <div class="content-sidebar">
      <div class="content"></div>
      <div class="sidebar"></div>
    </div>

С другой стороны, стили в случае с CSS-сетками получаются сложнее.
Придётся думать, чтобы добиться простого решения проблемы (если вы ещё не решали
эту проблему).

**А что выбрал бы я?**

Я, как и многие эксперты фронтенда, выбираю CSS-сетки (но я не смею называть
себя экспертом).

Если вам интересно, я написал [статью][3] о том, почему я выбрал
CSS-сетки вместо HTML-сеток. Также я написал [статью][4],
которая поможет вам перейти с HTML-сеток на CSS-сетки.

(Так много статей читать... :cry:)

В любом случае, вам нужно определиться с тремя вещами,
прежде чем создавать свою сетку. В целом, вот они:

1.  Дизайн сетки
2.  Как сетка ведёт себя на разных вьюпортах
3.  Что использовать - CSS-сетку или HTML-сетку?

Мы можем двигаться дальше, только определившись с этими вещами.
В этой статье условия таковы:

1. Сетка имеет максимальную *ширину в 1140px*, с *12 колонками по 75px* и
*отступами в 20px* ([откуда брать эти числа][2]).
2. Колонки меняют свой размер пропорционально вьюпорту, а *отступы
остаются фиксированными* ([почему я выбрал такое поведение][2]).
3. Я собираюсь создавать *CSS-сетку* ([почему я рекомендую такой подход][3]).

Итак, давайте начнём!

## Создаём сетку

Процесс создания сетки состоит из восьми шагов:

1.  Выбор технологии реализации
2.  Установка `box-sizing: border-box;`
3.  Создание контейнера
4.  Расчёт ширины колонок
5.  Определение положения отступов
6.  Создание отладочной сетки
7.  Вёрстка страницы
8.  Адаптация страницы для разных вьюпортов

Большинство из этих шагов становятся достаточно простыми, как только
вы проходите их хотя бы раз. Я объясню всё, что нужно знать для прохождения
каждого из них.

## Шаг 1: выбор технологии реализации

Что вы будете использовать для создания сетки — CSS-гриды, флексбокс или старые
добрые флоаты? Решения и детали реализации зависят от выбранной технологии.

CSS-гриды, безусловно, лучше всего подходят для создания сетки (потому что
*гриды* :sunglasses:). К сожалению, на данный момент поддержка гридов оставляет
желать лучшего. В каждом браузере они скрыты за флагом, поэтому мы не будем
рассматривать гриды в этой статье (*прим. редактора: на момент публикации
перевода гриды уже поддерживаются без флагов в Chrome, Firefox и Safari*).
Я настоятельно рекомендую ознакомиться с [работой Рейчел Эндрю][5], если вы
хотите узнать о гридах больше.

Перейдём к флексбоксу и флоатам. Соображения по их применению схожи, так что
можете выбрать то, что вам по душе и двигаться далее. Я буду использовать
флоаты, потому что они проще и понятнее новичкам.

Если вы выбрали флексбокс, помните об отличиях от флоатов, которые нужно учесть.

## Шаг 2: установка `box-sizing: border-box`

Свойство `box-sizing` задаёт блочную модель, используемую браузерами для расчёта
свойств `width` и `height`. Выставляя свойству `box-sizing` значение
`border-box`, мы сильно упрощаем расчёт размеров колонок и отступов (позже вы
поймёте, почему).

Вот наглядная демонстрация того, как вычисляется `width` в зависимости от
значения свойства `box-sizing`:

![Свойство box-sizing и его влияние на расчёт ширины][6]

Обычно я устанавливаю значение `border-box` для всех элементов на сайте, 
благодаря чему расчёт ширины и высоты элементов работает консистентно
(и интуитивно понятно). Вот как я делаю это:

    html {
      box-sizing: border-box;
    }

    *,
    *:before,
    *:after {
      box-sizing: inherit;
    }

Примечание: если вам нужно более детальное объяснение работы свойства
`box-sizing`, я рекомендую вам [прочесть эту статью][7].

## Шаг 3: Создание контейнера

У каждой сетки есть контейнер, определяющий её максимальную ширину. Как правило,
я называю его `.l-wrap`. Префикс `.l-` означает layout (*раскладка*).
Я использую такое именование с тех пор, как изучил методологию [SMACSS][8]
[Джонатана Снука][9].

    .l-wrap {
        max-width: 1140px;
        margin-right: auto;
        margin-left: auto;
    }

Примечание: для лучшей доступности и отзывчивости я настоятельно рекомендую
использовать вместо пикселей относительные единицы измерения вроде `em` или
`rem`. В примерах я использую пиксели, потому что они проще для понимания.

## Шаг 4: Расcчитайте ширину колонок

Помните, что мы используем флоаты для вёрстки колонок и отступов? С флоатами
мы можем использовать только пять CSS-свойств для создания колонок и отступов
(в случае с флексбоксом их немного больше):

* `width`
* `margin-right`
* `margin-left`
* `padding-right`
* `padding-left`

Если вы помните, при использовании CSS-сеток разметка выглядит примерно так:

    <div class="l-wrap">
      <div class="three-col-grid">
        <div class="grid-item">Grid item</div>
        <div class="grid-item">Grid item</div>
        <div class="grid-item">Grid item</div>
      </div>
    </div>

Из этой разметки понятно, что сетка имеет всего три колонки. Также видно, что
для создания отступов нет дополнительных `<div>`. Это означает, что:

1. Мы создаём колонки с помощью свойства `width`;
2. Мы создаём отступы с помощью свойств `margin` или `padding`.

Думать о колонках и отступах одновременно сложно, поэтому давайте для начала 
представим, что делаем сетку без отступов.

Эта сетка будет выглядеть примено так:

![Трёхколоночная сетка без отступов][10]

А теперь нужно сделать немного математических вычислений. Мы знаем, что сетка
имеет максимальную ширину в `1140px`, значит ширина каждой колонка — `380px`
(1140 ÷ 3).

    .three-col-grid .grid-item {
      width: 380px;
      float: left;
    }


Пока всё хорошо. Мы сделали сетку, которая отлично работает на вьюпортах больше
`1140px`. К сожалению, всё ломается, когда вьюпорт становится меньше.

![Сетка ломается, когда вьюпорт меньше 1140px][11]

Это значит, что мы не можем использовать пиксели в наших расчетах. Нам нужна единица измерения, которая сможет перестроиться в соответствии с шириной контейнера - проценты (`%`). Поэтому, пропишем ширину в процентах:

    .three-col-grid .grid-item  {
      width: 33.33333%;
      float: left;
    }

Полученный выше код - это простая трех-колоночная сетка без каких-либо отступов. Когда браузер меняет размер, эти три колонки пропорционально изменяются в размере.<figure>

![Три колонки без отступов][12]<figcaption>Три колонки без отступов</figcaption></figure>

Еще кое-что, перед тем как мы двинемся дальше. Всякий раз, когда все дочерние элементы в контейнере имеют обтекание, высота контейнера схлопывается. Этот феномен называется [схлопывание флоата][13]. Это как если бы в контейнере не было бы никаких дочерних элементов:<figure>

![Схлопывание флоата. Изображение с CSS Tricks][14]<figcaption>Схлопывание
флоата (изображение с CSS Tricks)</figcaption></figure>

Для того, что бы это исправить, нам нужен clearfix, который выглядит следующим образом:

    .three-col-grid:after {
      display: table;
      clear: both;
      content: '';
    }

Если вы используете препроцессор вроде Sass, вы можете сделать примесь,
которая позволит вам использовать этот код в разных местах:

    // Clearfix
    @mixin clearfix {
      &:after {
        display: table;
        clear: both;
        content: '';
      }
    }

    // Usage
    .three-col-grid { @include clearfix; }

После того как мы закончили с колонками, следующим шагом создадим несколько отступов.

## Шаг 5: Определите расположение отступов {#шаг-5-определите-распложение-отступов}

Итак, мы знаем, что должны создать отступы либо со свойством `margin`, либо со свойством `padding`. Но что использовать?

Сделав несколько набросков, вы быстро поймете, что есть четыре возможных способа как сделать эти отступы. Отступы могут быть расположены:

1.  *с одной стороны*, в виде *внешних отступов*
2.  *с одной стороны*, в виде *внутренних отступов*
3.  равномерно *с обоих сторон*, в виде *внешних отступов*
4.  равномерно *с обоих сторон*, в виде *внутренних отступов*<figure>

![4 возможных способа создать колонки и отступы][15]<figcaption>4 возможных способа создать колонки и отступы</figcaption></figure>

Здесь начинаются сложности. Вам нужно по-разному рассчитать ширину колонок
в зависимости от используемого метода.

Рассмотрим эти методы один за другим и посмотрим на разницу. Не торопитесь, пока вы читаете о них.

Поехали:

### Метод 1: Односторонние отступы (внешние)

Используя этот метод, вы создаете отступы при помощи свойства `margin`. Этот отступ будет расположен слева или справа от колонки. Вам решать какую сторону выбрать.

В рамках этой статьи, давайте предположим, что вы задаете отступы справа. Вот что вы будете делать:

    .grid-item {
      /* Need to recalculate width property */;
      margin-right: 20px;
      float: left;
    }


Затем пересчитываете ширину колонки как на картинке:<figure>

![Односторонние отступы с использованием внешних отступов][16]<figcaption>Односторонние отступы с использование внешних отступов</figcaption></figure>
Как вы видите на картинке выше, *1440px* это *три колонки* и *два отступа*.

И тут появляется проблема... Нам нужно, чтобы колонки были описаны в процентах, но в то же время отступы зафиксированы на ширине 20px. Мы не можем делать вычисления с двумя разными единицами измерения одновременно!

Это было невозможно раньше, но возможно сейчас.

Вы можете использовать CSS-функцию `calc` для сочетания процентов с другими единицами измерения. Она «на лету» извлекает значение процентов для выполнения вычислений.

Это значит, что вы можете задать ширину в виде функции, и браузер автоматически рассчитает ее значение:

    .grid-item {
      width: calc((100% - 20px * 2) / 3);
      /* other properties */
    }


Это круто.

После получения ширины колонки, вам нужно удалить последний отступ у крайнего правого элемента сетки. Вот как это можно сделать:

    .grid-item:last-child {
      margin-right: 0;
    }

Чаще всего, когда вы удаляете последний отступ у крайнего правого элемента, вы также хотите задать ему обтекание по правой стороне для предотвращения ошибок субпикселного округления, из-за которых ваша сетка переносит последний элемент на новую строку. Это происходит только в браузерах, которые округляют пикселы.
<figure>

![Ошибка субпикселного округления может сломать сетку, вытолкнув последний элемент на следующую строку][17]<figcaption>
Ошибка субпикселного округления может сломать сетку, вытолкнув последний элемент на следующую строку</figcaption></figure>
​    
    .grid-item:last-child {
      margin-right: 0;
      float: right;
    }

Фух. Почти готово. И еще одна вещь.

Наш код хорош только в том случае, если сетка содержит лишь одну строку. Однако, он не обрезает их, если строк с элементами больше чем одна :cry:<figure>

![Наш код лажает, если строк больше чем одна][18]<figcaption>Наш код лажает, если строк больше чем одна</figcaption></figure>

Нам нужно удалить правый внешний отступ у каждого крайнего правого элемента в каждой строке. Лучший способ  это сделать - использовать `nth-child()`:


    /* For a 3-column grid */
    .grid-item:nth-child(3n+3) {
      margin-right: 0;
      float: right;
    }

Это все, что нужно для создания односторонних внешних отступов. Вот codepen, что бы вы могли поиграться с этим:

See the Pen [Односторонняя сетка с использованием внешних отступов][19] by Zell Liew ([@zellwk][20]) on [CodePen][21].

Примечание: Свойство Calc не работает в IE8 и Opera mini. Вы можете посмотреть другие методы, если вам необходимо поддерживать эти два браузера.

### Метод 2: Односторонние отступы (внутренние)

Как и с односторонними внешними отступами, в этом методе требуется разместить отступы на одной из сторон колонки. Предположим, что вы снова выбрали правую сторону.

    .grid-item {
      /* width property */
      padding-right: 20px;
      float: left;
    }

Затем, вы можете пересчитать ширину колонки как на картинке:<figure>

![Односторонние отступы с использованием внутренних отступов][22]<figcaption>Односторонние отступы с использованием внутренних отступов</figcaption></figure>

Обратили внимание, что ширина отличается от предыдущего метода? Мы переключили свойство `box-sizing` в `border-box`. Теперь `width` рассчитывается, включая в себя `padding`.

В этом случае, две из трех колонок имеют бОльшую ширину, чем последняя, что в конечном итоге приводит к причудливым расчетам и делает CSS код трудным для понимания.

Я предлагаю даже не продолжать этот метод. (Он станет действительно уродливым. Пробуйте на свой страх и риск.)

### Метод 3: Разделенные отступы (внешние) {#method-3-split-gutters-margin-}

В этом методе мы разделяем отступы на две части и размещаем по половине с каждой стороны колонки. Код выглядит примерно так:


    .grid-item {
      /* Width property */
      margin-right: 10px;
      margin-left: 10px;
      float: left;
    }


Затем пересчитываем ширину колонки как на картинке:<figure>

![Разделение внешних отступов][23]<figcaption>Разделение внешних отступов</figcaption></figure>

Как мы узнали ранее, рассчитать ширину колонки можно с помощью функции `calc()`. В данной ситуации мы отнимаем три отступа от 100%, прежде чем делить ответ на три для получения ширины колонки. Другими словами, ширина колонки будет `calc((100% - 20px * 3) / 3)`.

    .grid-item {
      width: calc((100% - 20px * 3) / 3);
      margin-right: 10px;
      margin-left: 10px;
      float: left;
    }


Это все! (Вам не нужно ничего дополнительно делать для сеток с несколькими строками :wink:).
Вот codepen, что бы вы могли поиграться с этим:

See the Pen [Сетка с внешними разделенными отступами][24] by Zell Liew (
[@zellwk][20]) on [CodePen][21].

### Метод 4: Разделенные отступы (внутренние) {#method-4-split-gutters-padding-}

Этот метод аналогичен предыдущему. Мы делили отступы и размещали их с каждой стороны колонки. На этот раз мы используем внутренние отступы:

    .grid-item {
      /* width property */
      padding-right: 10px;
      padding-left: 10px;
      float: left;
    }


Затем вы рассчитываете ширину колонки так:<figure>

![Разделенные внутренние отступы][25]<figcaption>Разделенные внутренние отступы</figcaption></figure>

Обратили внимание, что в этот раз гораздо легче делать расчеты? Все верно; это треть ширины сетки в каждой контрольной точке.

    .grid-item {
      width: 33.3333%;
      padding-right: 10px;
      padding-left: 10px;
      float: left;
    }


Вот codepen, что бы вы могли поиграться с этим:

See the Pen [Сетка с внутренними разделенными  отступами][26] by Zell Liew (
[@zellwk][20]) on [CodePen][21].

Прежде чем мы двинемся дальше, я хочу вас предостеречь, если вы используете разделенные внутренние отступы. Если вы взгляните на разметку в Codepen, то увидите, что я добавил дополнительный `<div>` внутри `.grid-item`.  Этот дополнительный `<div>` важен, если компонент содержит фон или границы.

Это потому что фон отображается на внутренних границах. Эта картинка должна помочь(я надеюсь) разобраться, показав связь между `background` и другими свойствами.<figure>

![Фон отображается на внутренних границах][27]<figcaption>Фон отображается на внутренних границах</figcaption></figure>


### Что бы я использовал? {#что-бы-я-использовал}

Когда я начинал кодить сетки два года назад, я в основном делал сетки, которые
были спроектированы по [нисходящему подходу][28] и построены на
 [гибридной системе][29]. В таком подходе/системе, *я использовал процентные значения*
 *и для ширины, и для отступов*

В то время, я любил простоту настроек отступов с одной стороны колонки. Это было менее
напряжно для меня, потому что я довольно плох в математике. Дополнительные
`отступы / 2` расчеты быстро вырубали меня.

Я благодарен, что я пошел этим путем. Хоть CSS и выглядит более сложным, чем
для разделенных отступов, я был вынужден изучить [свойство nth-child][30]. Я также
понял важность написания [CSS сперва для мобильных][31]. Насколько я могу судить,
это до сих пор является главным препятствием и для молодых, и для опытных
разработчиков.

Так или иначе, если вы попросите меня выбрать сейчас, **я выберу разделенные отступы**
вместо односторонних, потому что CSS для них более простой. Также,
**я рекомендую использовать внешние отступы**  вместо внутренних, потому что
разметка получается чище. (Но *внутренние отступы легче рассчитать*, поэтому я продолжу
статью с внутренними отступами).

## Шаг 6: Создайте отладочную сетку {#шаг-6-создайте-отладочную-сетку}

Когда вы только начинаете, особенно полезно иметь под рукой контрольную сетку,
которая поможет отладить вашу разметку. Это помогает быть уверенным, что
вы все делаете правильно.

На данный момент, мне известен лишь кривой способ создания отладочной сетки. Нужно
создать HTML разметку и добавить к ней немного CSS. Вот так примерно выглядит HTML:

    <div class="fixed-gutter-grid">
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
      <div class="column"></div>
    </div>


  CSS для отладочной сетки выглядит следующим образом (я использую разделенные внешние отступы
для упрощения разметки отладочной сетки):


    .column {
      width: calc((100% - 20px * 12) / 12);
      height: 80px;
      margin-right: 10px;
      margin-left: 10px;
      background: rgba(0, 0, 255, 0.25);
      float: left;
    }


See the Pen [Отладочная сетка с фиксированными отступами][32] by Zell Liew ([@zellwk][20]) on
[CodePen][21].

(Ультра ремарка: Сьюзан Мириам (Suzanne Miriam) and Собрал Робсон (Sobral Robson) работают
над [фоновым SVG изображением отладочной сетки для Susy v3][33]. Это очень захватывающе,
так как вы можете использовать простую функцию для создания вашей отладочной сетки!)


## Шаг 7: Внесите изменения в раскладку {#шаг-7-внесите-изменения-в-раскладку}

Следующий шаг заключается во внесении изменений в раскладку на основе
вашего контента. Именно здесь CSS-сетка засияет во всей красе. Вместо того, что бы создавать
разметку с написанием множества сеточных классов, вы можете создать для нее 
подходящее имя.

Для примера допустим, что у вас есть сетка для раскладки, которая
используется только для гостевых статей. Для десктопа раскладка выглядит
примерно так:<figure>

![Пример сетки для раскладки, которая используется только для гостевых статей][34]<figcaption>
Пример сетки для раскладки, которая используется только для гостевых статей</figcaption></figure>

Разметка для раскладки этой гостевой статьи может быть такой:

    div class="l-guest-article">
      <div class="l-guest"> <!-- Guest profile --></div>
      <div class="l-main"><!-- main article--></div>
      <div class="l-sidebar"><!-- sidebar widgets--></div>
    </div>


Итак, сейчас у нас есть 12 колонок. Ширина одной колонки 8.333%
`(100 / 12)`.

Ширина `.l-guest` равна двум колонкам. Поэтому вам нужно умножить
8.333% на два. Достаточно просто. Проделайте тоже самое для остальных элементов.

Тут я предлагаю использовать препроцессор типа Sass, который позволит вам рассчитывать
ширину колонок легче, используя функцию `percentage`, вместо расчетов вручную:

    .l-guest-article {
      @include clearfix;
      .l-guest {
        // Хм. Читается удобнее, чем 16.666% :)
        width: percentage(2/12);
        padding-left: 10px;
        padding-right: 10px;
        float: left;
      }

      .l-main {
        width: percentage(7/12);
        padding-right: 10px;
        padding-left: 10px;
        float: left;
      }

      .l-sidebar {
        width: percentage(3/12);
        padding-right: 10px;
        padding-left: 10px;
        float: left;
      }
    }


See the Pen [Сетка с фиксированными отступами для раскладки гостевой статьи][35] by Zell Liew
([@zellwk][20]) on [CodePen][21].

Должно быть вы заметили, что сейчас часть кода повторяется. Мы можем это исправить вынеся общие части кода 
в отдельный селектор `.grid-item`.

    .grid-item {
      padding-left: 10px;
      padding-right: 10px;
      float: left;
    }

    .l-guest-article {
      .l-guest { width: percentage(2/12);}
      .l-main { width: percentage(7/12);}
      .l-sidebar { width: percentage(3/12); }
    }


Вот так, теперь гораздо лучше. :)

## Шаг 8: Сделайте вашу раскладку адаптивной {#шаг-8-сделайте-вашу-раскладку-адаптивноой}

Последний шаг - это сделать вашу раскладку адаптивной.
Давайте предположим, что раскладка нашей гостевой статьи ведет себя
следующим образом:<figure>

![Как раскладка гостевой статьи ведет себя на различных вьюпортах][36]<figcaption>
Как раскладка гостевой статьи ведет себя на различных вьюпортах</figcaption></figure>

Разметка нашей гостевой статьи не должна меняться. То, что у нас есть - это
самая доступная раскладка, которая у нас может быть. Так что, изменения должны
быть полностью в CSS.

При написании CSS для нашей отзывчивой гостевой раскладки, я настоятельно рекомендую
вам писать [CSS сперва для мобильных][37], потому что это делает ваш код проще и
аккуратнее. В первую очередь, мы можем начать писать CSS для мобильной раскладки.

Вот код:

    .l-guest-article {
      .l-guest { /* nothing goes here */ }
      .l-main {
        margin-top: 20px;
      }
      .l-sidebar {
        margin-top: 20px;
      }
    }
 
Нам здесь нечего делать, т.к. каждый компонент занимает всю доступную ширину по
умолчанию. Однако, мы можем добавить верхний отступ к последним двум элементам,
что бы отделить их друг от друга.

Далее, давайте двигаться к планшетной раскладке.

Давайте предположим, что для этой раскладки мы установим контрольную точку в 700px. 
.l-guest должен быть  4 из 12 колонок, в то время, как .l-main и .l-sidebar должны
занимать по 8 колонок каждый.

Здесь нам надо удалить свойство `margin-top` у `.l-main`, потому что он должен
быть на одной линии с `.l-guest`.

Также, если мы установим .l-sidebar в ширину 8 колонок, то он автоматически перейдет
во второй ряд, т.к. в первом ряду не хватит места. Поскольку он находится во втором
ряду, нам также надо добавить внешний отступ слева у .l-sidebar, чтобы протолкнуть
его на позицию; в качестве альтернативы, мы можем сделать его обтекаемым справа
(я добавлю обтекание справа, т.к. нет необходимости что-либо высчитывать).

Наконец, т.к. мы сделали наши грид-элементы обтекаемыми, грид-контейнер должен включать
в себя clearfix, чтобы очистить обтекание у дочерних элементов:


    .l-guest-article {
      @include clearfix;
      .l-guest {
        @media (min-width: 700px) {
          width: percentage(4/12);
          float: left;
        }
      }
      .l-main {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          margin-top: 0;
          float: left;
        }
      }
      .l-sidebar {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          float: right;
        }
      }
    }


И наконец, давайте перейдем к настольной раскладке.

Для этой раскладки, допустим, мы установим контрольную точку
в 1200px. `.l-guest` должен занимать 2 из 12 колонок,`.l-main` должен
занимать 7 из 12 колонок, и `.l-sidebar` должен занимать 3 из 12 колонок.

Что мы делаем, так это создаем новый медиа запрос в рамках каждого элемента
сетки и изменяем ширину по необходимости. Обратите внимание, что мы
также должны удалить верхний отступ у `.l-sidebar`


    .l-guest-article {
      @include clearfix;
      .l-guest {
        @media (min-width: 700px) {
          width: percentage(4/12);
          float: left;
        }

        @media (min-width: 1200px) {
          width: percentage(2/12);
        }
      }
      .l-main {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          margin-top: 0;
          float: left;
        }
        @media (min-width: 1200px) {
          width: percentage(7/12);
        }
      }
      .l-sidebar {
        margin-top: 20px;
        @media (min-width: 700px) {
          width: percentage(8/12);
          float: right;
        }
        @media (min-width: 1200px) {
          width: percentage(3/12);
          margin-top: 0;
        }
      }
    }


Вот codepen с финальной раскладкой, которую мы создали:

See the Pen [Сетка с фиксированными отступами для раскладки гостевой статьи (финальная версия)][38]
by Zell Liew ([@zellwk][20]) on [CodePen][21].

(О, кстати, вы также можете добиться таких результатов со Susy.
Только не забудьте выставить [gutter-position][39] в `inside-static`).

## Подводя итог

Ого. Это длинная статья. Я думал, что трижды умру, пока писал её. (Спасибо,
что дочитали до конца. Надеюсь, вы не умерли трижды, пока читали! :stuck_out_tongue:).

Как вы можете заметить в этой статье, шаги для создания адаптивной сетки относительно
просты. Этапами, с которыми путаются большинство людей, 
являются шаги 5 (определение положений отступов) и 8 (делая раскладку
адаптивной).

Шаг 5 прост, когда вы учитываете все возможные способы, и мы разобрали их вместе.
А Шаг 8 легко решаем если у вас достаточно опыта
в написании [CSS сначала для мобильных.[37].

Надеюсь, эта статья дала вам знания для построения вашей собственной 
адаптивной сетки, и я надеюсь увидеть как вы строите специально созданную сетку для 
вашего следующего проекта.

До скорого!

[1]: https://zellwk.com/blog/designing-grids
[2]: https://zellwk.com/blog/designing-grids/
[3]: https://zellwk.com/blog/migrating-from-bootstrap-to-susy/
[4]: https://zellwk.com/blog/from-html-grids-to-css-grids/
[5]: http://gridbyexample.com
[6]: img/box-sizing.jpg
[7]: https://zellwk.com/blog/understanding-css-box-sizing/
[8]: https://smacss.com
[9]: https://twitter.com/snookca
[10]: img/columns.png
[11]: img/grid-break.gif
[12]: img/grid-columns.gif
[13]: https://css-tricks.com/all-about-floats/
[14]: img/float-collapse.png
[15]: img/combi.png
[16]: img/pattern-1side-margin.png
[17]: img/subpixel.png
[18]: img/margin-side-last-child.png
[19]: http://codepen.io/Lesnevskiy/pen/RoZpva
[20]: http://codepen.io/Lesnevskiy
[21]: http://codepen.io
[22]: img/pattern-1side-gutter.png
[23]: img/pattern-split-margin.png
[24]: http://codepen.io/Lesnevskiy/pen/KNvWYR
[25]: img/pattern-split-padding.png
[26]: http://codepen.io/Lesnevskiy/pen/qqXrzB
[27]: img/bg-relationship.jpg
[28]: https://zellwk.com/blog/designing-grids/#how-big-should-columns-and-gutters-be-
[29]: https://zellwk.com/blog/designing-grids/#how-the-grid-responds-to-different-viewports
[30]: https://css-tricks.com/examples/nth-child-tester/
[31]: https://zellwk.com/blog/how-to-write-mobile-first-css/
[32]: http://codepen.io/Lesnevskiy/pen/RoZVbG
[33]: https://github.com/oddbird/susy/issues/609
[34]: img/grid-example.png
[35]: http://codepen.io/Lesnevskiy/pen/QGMvLm
[36]: img/grid-responsive.png
[37]: https://zellwk.com/blog/mobile-first-css/
[38]: http://codepen.io/Lesnevskiy/pen/zodwOQ
[39]: https://zellwk.com/blog/susy-gutter-positions/
